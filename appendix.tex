\chapter{TCPに関する補講}

本章では、TCPに関する、少し突っ込んだ内容を補講的に記載します。いずれも、ネットワークアプリケーションを開発するときには、必要となる内容です。

\section{遅延ACKの無効化}

TCPでは、遅延ACKを無効化することができる。
例えば、Linuxで遅延ACKを無効化するには、setsockopt(2)にTCP\_QUICKACKオプションを設定する。だが、 TCP\_QUICKACKはそのプロセスから利用するTCPスタックの動作を、プロセス終了まで恒久的に変化させるものではない。カーネル側動作や他プロセスの都合で遅延ACKモードに入っている可能性がある。そのため、セグメント受信ごとにsetrsockopt(2)で設定しなおす必要がある場合がある。

一方、BSDの実装では、遅延ACKは、sysctlによるシステム変数の設定で無効にすることができる。

\section{最大セグメントサイズ(MSS Maximum Segment Size)}

SYNを送信しあうコネクション確立時に、アクティブオープン側とパッシブオープン側は、最大セグメントサイズ(MSS Maximum Segment Size)という情報を交換する。

インターネットプロトコルスイートでは、トランスポート層から来たデータを、ネットワークアクセス層で送信可能な大きさに分割(フラグメント)し、自分がフラグメントとされたデータグラムの宛先であれば、再構成してトランスポート層に渡すのは、インターネットプロトコル層の役割である。だが、インターネットプロトコル層では、規定の時間までにフラグメントされた断片が揃わない場合、分割前のデータを構成する全てのデータグラムを破棄することになっている。これは、TCPの役割である確実な通信の妨げになる。

そこで、通信の相手に、自分に対してデータを送るとき、セグメントの大きさの上限をいくつにすれば、途中でフラグメントが発生しないかを通知する。通信の相手が、インターネットプロトコル層での同じネットワークに属しれいれば、実際にデータを送信するネットワークアクセス層でのMTUから、TCPと IPのヘッダに消費する40byteを引いた値とする。

また、通信の相手が、インターネットプロトコル層で言うところの異なるネットワークにある場合は、MSSには、536もしくは、そのトランスポート層の下位であるネットワークアクセス層のMTUから算出した値の小さい方を用いる。

\subsection{異なるネットワークへ通信する際のMSS}

ここで注意すべきなのは、異なるネットワークへの通信時に、MSSを算出する際の基準は、デフォルト値536と、通信を開始しようとするトランスポート層の下位に存在するネットワークアクセス層でのMTUのみであるとことである。例えば、二つのイーサネットがMTU256byteのシリアル回線で接続されていたとしよう。片方のネットワークにあるホスト（のトランスポート層）が、もう片方のネットワークにあるホストにSYNを送ろうとしたとする。この場合、イーサネットのMTU1500から40を引いた1460byteと、異なるネットワークへの通信時のデフォルト値536を比較して、より小さい536 がMSSとして用いられる。

そのため、イーサネットとシリアルという異なるネットワークアクセス層をつなぐインターネットプロトコル層（ルータもしくはゲートウエイ）で、フラグメントが発生する。

このフラグメントが発生しないようにするためには、パスMTUディスカバリ(PMTU)という、途中経路の最小MTUを検出する仕組みを用いる必要がある。

\section{Nagleのアルゴリズム}

インタラクティブ型のアプリケーションの通信をTCPで行う場合、1キャラクタ(1オクテット）送信、エコーバックにACKがピギーバック、次に送出するキャラクタにエコーバックへのACKをピギーバック…というように、タイニーグラムと呼ばれる、データ部分の小さいセグメントの送出がお互いに繰り返される。最悪、TCPヘッダ20オクテット、IPヘッダ20オクテットにデータ1オクテットという、ほとんどがヘッダというIPデータグラムが大量に、ネットワークに垂れ流されることになる。

たとえばtelnetのクライアント側ででhelloという文字列をキーストロークしたとしよう。改行を考えなければ5文字である。1キャラクタ1セグメントで送信すると、キャラクタあたり41オクテットの送出なので、合計205オクテットが送信される。また、5セグメント分のACKとエコーバック（1セグメント1文字）として、同じく205オクテットがサーバからクライアントへの向きに送出される。

エンドツーエンドのセグメント送出とそれに対するACKの往復時間(RTT Round Trip Time)が十分に短ければ、大量のタイニーグラムを送りあっても問題は生じない。だが、RTTが長い場合は、大量のタイニーグラムは、遅延の原因となる。

遅い通信環境で、タイニーグラムによる遅延を緩和するために、RFC896で提案されたのがNagleのアルゴリズムである。

Nagleのアルゴリズムとは、セグメントは、ACKが戻ってから送出する、というものである。たったこれだけのアルゴリズムが遅延の回避にどのように役立つかを説明しよう。

直前のセグメントで送出したデータ（さんざん繰り返したが、直前のセグメントに対して、ではない）についてのACKが戻るには、いくらかの時間がかかる。つまり、RTTは0でなく、その時点の通信回線や相互の通信能力などに依存した大きさを持つ。 TCPはストリーム型の通信なので、RTTの時間で、送信すべきデータが溜まることを期待できる。例えばそれは、ユーザのキーストロークによる入力が該当するだろう。

前述した例であれば、telnetのクライアントで、ユーザがhelloというフレーズを入力しようとしているとする。最初の一文字、hは入力された時点で送出される。そのエコーバック(hのACKがピギーバックしている）が戻ってくるまでの時間で、elloが入力されたとしよう。この場合、クライアント側のTCPは、最初に送出したhのACKが戻ってから、elloという4キャラクタを送出する。このセグメントには、hのエコーバックへのACKがピギーバックしている。

telnetサーバ側では、hのエコーバックへのACKが戻ったので、次のセグメントを送出することができる。このときに、エコーバックすべき文字がelloの4キャラクタあるので、それをエコーバックする。

Nagleのアルゴリズムに従って送出した場合、クライアントからサーバへは41+44で85オクテット、サーバからクライアントへのエコーバックは同様に85オクテットとなる。

Nagleのアルゴリズムの利点は、RTTがそのまま通信のセルフクロックになることである。RTTが短ければ、溜まるデータも少ないが、この場合はタイニーグラムを送出してもまあ問題はないだろうということになる。逆に、RTTが長ければ、溜まるデータが多いので、送出されるセグメント数が減り、結果、ヘッダによるオーバヘッドも減少する。

\subsection{Nagleアルゴリズムを使用しない場合}

Nagleのアルゴリズムは、ACK到着をタイミングに使ってデータを溜めることで、送出されるデータグラム（具体的にはTCPヘッダとIPヘッダ）を、回線速度に見合った量にする。だが逆に、リアルタイムなユーザ入力に対応したい場合など、入力から応答(ACK)までの時間を短くしたい場合もある。

たとえば、X-WindowのXserverと接続を行う際は、Nagleアルゴリズムが無効となっている。また、ネットゲームの通信にTCPを使用する場合、入力に対するレスポンスを早くするためにNagleのアルゴリズムを無効化することがある。この場合、タイニーグラムの応答速度が向上する。だが、通信におけるヘッダの量が大きくなるため、帯域をより多く必要とする。

Nagleのアルゴリズムを無効にするには、setsockopt(2)で、TCP\_NODELAYオプションを有効にする。

\section{スロースタート}

本書のここまでの説明では、広告されたウインドウサイズの範囲で、送信可能な一杯のデータを送っていた。だが、ルータを経由して通信する場合、それは大量のデータグラムの中継をおこなうということであり、途中経路の負荷となって、データグラムが破棄され、再送による性能低下につながる。

そこで、TCPでは、通信相手がACKを返す能力を計ることで、それに応じてどれぐらいのセグメントを送出するか決定するアルゴリズムを用いる。これを、スロースタートという。

スロースタートでは、送信側に輻輳ウィンドウ(cwnd corrision Window)という、ウインドウを追加する。3way Handshake直後は、cwndの大きさは1セグメント（つまり、相手から通知されたMSSの大きさ）である。送信側は、cwndと、相手から通知されるRWINの、小さい方の値までデータを送信することができる。

送信側は、最初は1セグメントだけデータを送信する。それに対してのACKが帰ったら、cwinは1セグメント分大きくなる。。次にデータを送出するときは、2セグメントを送信する。この2セグメントに対して、一つのACKが戻ったら1セグメント分、二つのACKが戻ったら2セグメント分、cwndが大きくなる。つまり、タイムラインで戻ったACKの個数分だけcwndが大きくなる。

スロースタートの終了条件は、どのように決まるのだろうか。
送出するセグメント数が限界を超えると、途中経路のインターネットプロトコル層で遅延が生じたり、フラグメントされたデータグラムが揃わなかったりする。

これを送信側から見ると、、送出したセグメントへのACKが戻らなくなる。それによって、送信側はcwndが上限に達したことを知ることができる。この終了条件については、輻輳回避アルゴリズムについての説明で改めて説明しよう。

\section{輻輳回避アルゴリズム}

セグメントの再送が必要になるほとんどの理由は、経路に輻輳が発生したことである。そのため、セグメント再送を行うと共に、その輻輳に巻き込まれないようにしたほうが、確実な通信ができる。では、輻輳回避はどのようにおこなえばいいのであろうか。輻輳は、重複ACKが到着する、もしくは、RTOになってもACKがとどかない、このいずれが発生することで知ることができる。

輻輳回避の目的は、現在の経路の状況をはかって、途中でデータグラムを捨てられない頻度での送信を行うことである。通信相手がACKを返す能力を測ることが目的のスロースタートとは似て異なるので、その点注意が必要である。

輻輳回避は、スロースタートと同様に、輻輳ウィンドウ(cwnd)を使用する。また、スロースタート閾値(sstresh)という変数を導入する。そのため、スロースタートと輻輳回避は同一の機能として実装されることが多い。

\begin{enumerate}
\item  3way Handshake直後は、cwndは相手のMSSと同じ大きさ（こちらが送信する1セグメントの大きさ）、$ssthresh=65535$に初期化される。このsstreshの値は、TCPのセグメントサイズの最大値に等しい。
\item TCPでは、cwndと、通信相手のウインドウ・サイズ広告を比較し、小さいほうの大きさを上限としてデータを送信する。この、送信できるデータの大きさの上限を、現行ウインドウサイズと呼ぶ。ここまではスロースタートの動作である。
\item 輻輳が発生したら、現行ウインドウサイズの大きさの$1/2$がsstreshとなる。ただし、ssthreshの最小値は、2セグメント分（MSSの倍）となる。さらに、タイムアウト発生であれば、cwndを1セグメントにする。つまり、タイムアウトの場合は以下の手順がスロースタートのものとなる。
\item  再送したデータの応答確認がされたら、cwndとsstreshを比較する。
           $cwnd≦sstresh$の場合、スロースタートする。
$cwnd>sstresh$の場合、cwndをセグメント数に換算して、$1/cwnd$の大きさが表すセグメントの数）ずつ増加する。つまり、現在のcwndに応じて、MSSを小分けした大きさで増加する。
.
\end{enumerate}

ここで、スロースタート/輻輳回避アルゴリズムには、終了条件がないことに気がついただろうか?このアルゴリズムには、どこでcwndの増加を止めるかという定義がない。そのままにしておくと、cwndはどんどん大きくなりそうである。

だが、cwndがどんなに大きくなっても、通信の相手からのウインドウサイズ広告という送出データ量の上限が存在する。

ウインドウサイズ広告が十分に大きい場合でも、cwndがある程度大きくなった場合、それが輻輳の原因となりうる。同一のコネクションで輻輳が発生する毎に、sstreshは輻輳発生直前の現行ウインドウサイズの半分になる。もしタイムアウトが生ずれば、cwndを初期化してスロースタートからはじめることになる。sstreshはスロースタートと輻輳回避を切り替える閾なので、あるところからcwndの大きさの増加がゆるやかになる。

重複ACKの場合はcwndの初期化はないが、その後のcwndの増加は輻輳回避アルゴリズムに従った緩やかなものとなる。

この動作を繰り返していけば、データの送出量は、そのコネクションのその時点における適切な値に収束するであろう。\footnote{実際は、適切な値の周辺で振動することになる}その結果、インターネットプロトコル層レベルで捨てられるデータが発生すること、つまり輻輳を回避できる。

\subsection{Jacobsonの高速再転送と高速リカバリ}

重複ACKによって、輻輳を検知した場合、それは、セグメントのがシーケンス番号の順に届かなかった、もしくは、到着しなかったセグメントの存在、というどちらかが発生したことを示す。では、これを見分けることは可能であろうか?

セグメントの順番が狂った場合と、セグメントの脱落を区別するには、重複ACKの数で判断する。重複ACKが3個より少ない（つまり、同じ応答確認番号の ACKが2個もしくは3個届いた）場合は、おそらくセグメントの到着順が前後したが相手に受信され、その結果新しい応答確認番号でACKが帰ってきた、と判断できる。

一方、重複ACKが3個(同じ応答確認番号のACKが4個届いた）になった時点で、セグメントが相手に到着しなかったと判断すべきだろう。Jacobsonの高速再転送は、それを利用して、脱落したセグメントの再送信を行う。

\begin{enumerate}
\item 受信側は、セグメントが順番通りに届かなかった時点で、抜けているセグメントのシーケンス番号を応答確認番号とした重複ACKを、その後セグメントが到着する毎に送信する。
\item 送信側は、3個目の重複ACK(つまり、同じ応答確認番号のACKが4回到着したら）、その応答確認番号に対応するシーケンス番号のデータを再送する。これが、Jacobsonの高速転送である。
			\begin{enumerate}
            \item このとき、sstreshをcwndの$1/2$にする
            \item $cwnd = sstresh + 3MSS$ にする。
            \item 重複ACKが到着するごとに、$cwnd ← cwnd + MSS$ で、サイズを大きくする。
            \end{enumerate}
\item 送信側は、新しいcwndで送信が可能になれば、データを送信する。
\item 新しい確認応答番号のACKが戻れば、それは再送したセグメントが到着したということである。また、このACKは、消失したセグメントを送出してから、一つ目の重複ACKを受信するまでのセグメントすべての確認応答となる、確認応答番号を持っているはずである。さらに、セグメントを再送してからACKが戻るまでのRTTが経過したことになる。
\item     $cwnd = sstreesh$とする。つまり、セグメントの脱落を検出する前のcwndの$1/2$にする。
\end{enumerate}

再送手順と輻輳回避が一体となっているのはなぜだろうか?それは、重複ACKがあったということは、少なくとも消失したセグメント以降のデータは消失していないということであるからだ。そのため、スロースタートからはじめ直す必要はない。

また、cwndが大きくなって、許可されたら再送セグメントのACKを待たなくてもデータが送信できる、とはどういうことだろうか。重複ACKが到着している間は、受信側バッファに、脱落したセグメント以降に受信されたセグメントがためられている状態である。このセグメントのACKは、重複ACKとして返されている。再送セグメントの受信に成功したら、バッファに置かれているセグメントの再送の必要はなくなる。これが、Jacobsonの高速リカバリアルゴリズムである。

受信側でセグメントに置かれているデータを送信側から見れば、対応する確認応答番号でACKが戻っていない、つまり、送信中であり、送信側のcwnd の中に入っている状態である。
3回目の重複ACKが発生した時点で、多くの場合、cwndは小さくなる。
もし、cwndがその時点で「送出しているが ACKが戻らないデータの合計」より小さければ、時間経過でcwndが大きくなり、送出しているがACKが戻っていないセグメント全てがcwndにはいるまで、再送セグメントを除いて、ウインドウサイズ広告に余裕があってもデータは送信できない。
それによって、再送セグメントが入るべきバッファに新しいセグメントが入らないよう、再送セグメントが受信側のバッファにはいるまでの時間を稼ぐと考えればよいだろう。

再送したセグメントのACKが帰ったら、cwndをsstreshの値にして、以降は輻輳回避アルゴリズムに従ってcwndが増加するようにする。

\section{再転送と送信内容の再構築}

一番最後に送信したセグメントが再転送の対象になった場合など、脱落したセグメントと同一のセグメントを送信しなくても良い場合がある。

たとえば、インタラクティブなアプリケーションにTCPを使用していて、一番最後に送信したセグメントが脱落したとする。この場合、脱落したセグメントを送出してから、再送するまでの間に、送信すべきデータが追加されている場合がか起こりうる。このような場合、セグメントの大きさにデータを追加する余裕があれば、再送すべきデータとそれ以降追加されたデータを一緒に送信してもかまわない。、

\subsection{どれだけ待てばタイムアウトになるのか}

TCPのタイムアウトは、どのように決定されるのだろうか。それは、その時点で通信にかかる時間を基準にして、どれくらい待ったらタイムアウト扱いにしてセグメントを送信し直すかを計算で決定する。

そのためには、通信にかかる時間とはなにか、から定義する必要がある。それは、あるセグメントを送出してから、そのセグメント、もしくはそれ以降に送出したセグメントに対応した確認応答番号を持つACKが、一番最初に戻ってくるまでの時間である。だがこれは測定毎にばらつきのある実測値であり、そのままでは使用されない。

\subsection{古典的なタイムアウト時間の決定}

古典的な方法では、この測定値を元にしてローパスフィルタで通信の往復時間(RTT Round Trip Time)の評価値を出す。ある時点の測定値をMとすると、RTTの評価値Rは、平滑化計数αを用いて、以下の式で表される。


$R ← αR + (1-α)M$


つまり、これまでの評価からの値とその時点の実測値をある割合で混ぜて使う。平滑化計数の推奨値は$α=0.9$である。再送タイムアウト(RTO Resend Time Out)は、遅延分散計数βを用いて、

$RTO = Rβ$

として決定する。遅延分散計数の推奨値は$β=2$とされる。

古典的な方法の欠点としては、実数演算を行う必要があることがある。また、不必要な再転送によるRTTの変動に対処できないという問題\footnote{つまり、再転送が原因でRTTが変化し、待ち時間が足りずに再送を失敗する…というシナリオが発生する。}に対応できないことが、Jacobsonnによって指摘されている。

\subsection{Jacobsonの方法}

Jacobsonは、測定値Mから、平滑されたRTTの平均値Aと平滑化されたRTTの標準偏差Dを算出し、それを用いてRTOを決定する方法を提案した。現在、TCPでのRTOの決定に使用されている方法である。ここでは式だけを示すにとどめる。


初期RTO $RTO = A + 2D$


それ以降 


$Err = M - A $

$A ← A + gErr$

$D ← D + h(|Err| - D) $

$RTO = A + 4D \\$
ここで係数$g=1/8$、係数$h=1/4$である。この方法の利点は、一見すると式が増えているが、各変数に整数値を入れれば、整数演算とシフトだけで計算ができることである。

\subsection{再転送の曖昧性問題とKarnのアルゴリズム}

あるセグメントに対してのACKがタイムアウトして、再送したらACKが戻ってきたとする。このとき、このACKは最初に送ったセグメントに対して返されたものが、今頃戻ってきたものなのか、それとも、再送したセグメントに関して返されてものだろうか?TCPでは、この区別をつけることはできない。これを、再転送の曖昧性問題、という。

では、区別が付かないと何か都合が悪いことはあるのだろうか。セグメントを確実に送信する、という観点から見れば、不都合はない。だが、RTOを計算し直すためには、区別が付かないために最初に送信したセグメントからの時間を実測値とすればいいのか、送信し直したセグメントからの時間を実測値とすればいいのか判断できないことになる。

その解決方法はKarnのアルゴリズムとして提案されている。Karnのアルゴリズムでは、RTTの再評価は行わない、という、これ以上ないシンプルな方法を採る。それ以降で、再送していないセグメントと、そのセグメントへのACKによる実測値がとれるまで、RTTの再評価は行わない。つまり、RTOはそれまでの値がそのまま使用される。

