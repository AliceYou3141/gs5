\chapter{ICMPによるIP層通信の制御}

\begin{itemize}
\item 宛先到達不能(Destination Unreachable)
\item 時間切れ(Time Exceeded)
\item  パラメタ異常(Parameter Promblem)
\item 送信元抑制(Source Quench)
\item  リダイレクト(Redirect)
\item エコー/エコーリプライ(Echo/Echo Reply)
\item タイムスタンプ/タイムスタンプリプライ(Timestamp/Timestamp Reply)
\item 情報リクエスト/情報リプライ(Information Request/Informatin Reply)
\item アドレスマスクリクエスト/アドレスマスクリプライ(Address mask request/Address mask reply)
\end{itemize}
\subsection{宛先到達不能(ICMP\_DEST\_UNREACH)}

宛先到達不能では、データグラムなぜ到達しなかったかの情報が、ICMPヘッダに織り込まれる。

\begin{itemize}
\item ネットワーク到達不能
\item ホスト到達不能
\item プロトコル到達不能
\item ポート到達不能
\item フラグメントかが必要だが「フラグメント禁止」フラグがついている
\item ソースルーティングに失敗
\end{itemize}

\subsubsection{ネットワーク到達不能・ホスト到達不能・ソースルーティング失敗}

データグラムがなぜ宛先にたどり着かなかったかの情報である。ルータが、以下の判断をした場合、この宛先到達不能を送信してよいことになっている。

\begin{itemize}
\item 宛先フィールドにあるネットワークに到達できない
\item 自分が宛先ネットワークのルータであるときに、該当するホストがない
\item そのネットワークに至る経路情報を持っていない
\end{itemize}

\subsubsection{プロトコル到達不能・ポート到達不能}

宛先となるホストが存在しても、上位プロトコルで、そのデータグラムに乗っているデータを受け取れるものがない場合、宛先となっていたホストは、宛先到達不能を返して良い。このメッセージを返す場合の上位プロトコルは、トランスポート層と、アプリケーション層になる。

データグラム中のデータを渡す上位プロトコルが稼働していない場合は、インターネットプロトコル層がプロトコル到達不能を返す。トランスポート層からそのデータを渡す上位プロトコルがない場合は、トランスポート層がICMPを使用してポート到達不能メッセージを返す。

\subsubsection{フラグメントできない}

インターネットプロトコルのデータグラムのヘッダには、フラグメントを禁止するフラグがある。フラグメント禁止フラグが立っているときに、よりMTUの小さいネットワークが経路となる場合、ゲートウエイ(ルータ)は、宛先到達不能メッセージを送出する。

\subsubsection{到達不能を返さない場合がある}

ファイアウオールなどでインターネットプロトコルのデータグラムを捨てるときには、宛先到達不能メッセージは返さない。これは、RFCなどの規約ではなく、拒否するデータグラムを送信してきたホストに対して、よけいな情報を与えないための実装である。

\subsection{時間切れ ( ICMP\_TIME\_EXCEEDED)}

ここでいう時間とは、二つの意味がある。ひとつは、インターネットプロトコルのデータグラムのヘッダのTTLフィールドに書かれた、次のルータもしくはネットワーク\footnote{ネットワークの用語でNexthop、という}に転送可能な残り回数である。そして、もう一つは、実時間の場合である。
\subsubsection{転送可能な残り回数 (TTL)が0になった}

ルータは、データグラムを中継する際に、そのヘッダに記載されたTTLを1減らす。このとき、1減らすことでTTLが0になったデータグラムは、そのルータが破棄しなければならない(must)。その際に、データグラムの発信元に向けて時間切れメッセージを発信しても良い (may)。

\subsubsection{データグラムの宛先となっているインターネットプロトコル層で、フラグメントの再構築がタイムアウトした}

インターネットプロトコル層は、自分宛のデータグラムは、フラグメントを収集して、データ部分を再構築し、フラグメント前のデータに戻そうとする。その際、フラグメントのうち最初の1個を受信してから、全て受信するまでの、時間制限が設定される。データの断片であるフラグメントがそろわなかったことが理由で制限時間内にデータを再構築できなかった場合、全てのフラグメントを破棄し(must)、時間切れのICMPエコーメッセージを、そのデータグラムの送信元に送信しても良い(may)

\subsection{パラメータ異常(ICMP\_PARAMETERPROB)}

データグラムを処理(中継、受信など)しているホストやルータがデータグラムのヘッダ部分のパラメータ異常を検知し、それが原因で処理を完了できない場合は、そのデータグラムを破棄しなければならない(must)。このとき、送信元にパラメータ異常のICMPメッセージを送信しても良い(may)。

\subsection{送信元抑制 (ICMP\_SOURCE\_QUENCH)}

送信元抑制は、現在のRFCでは、発信する必要はないとされている。それには、以下で述べるようないくつかの理由がある。

まず、送信元抑制メッセージによってかえってネットワークの輻輳が発生することがある。また、送信元抑制メッセージを大量に送りつける攻撃があること、送信されるデータ量を抑えるように依頼するよりも、次章でに説明を行うTCPの輻輳防止機能を使用すれば済むということである。

このメッセージについての説明は、ICMPの機能の説明として記載する。だが、 LinuxのKernel2.2以降のサポートがなくなったなど、送信元抑制を使用する場面はなくなったと言ってもよいだろう。

ルータがデータグラムを中継する際に、必要なバッファ領域が不足した場合は、処理しきれないデータグラムをはきすることができる。例えば、速度が違うネットワークアクセス層を経由するために到着したデータグラムをバッファしている状態などが想定できるだろう。また、データグラムを破棄したルータは、破棄したデータグラムの送信元に対して送信元抑制のICMPメッセージを送信することができる(may)。

同様に、あるデータグラムの宛先となっているホストが、その受信処理能力を超えるデータグラムを送られたとき、破棄したデータグラムの送信元ホストに送信元抑制メッセージを送信しても良い(may)

ある特定の送信元からそのルータを経由するデータが多いから抑制してもらう、という統計的処理を行っているわけではないことに注意してほしい。処理しきれないことを理由に捨てたデータグラムの送信元が、送信元抑制メッセージの宛先となる。

送信元抑制のICMPメッセージを受けた側は、送信元抑制メッセージが来なくなるまでその宛先に送信するトラフィックを減らすべきである (should)。減らさなくてもかまわないが、そのときは途中で破棄されるパケットの数も変わらないので、結果としての所要時間は変わらない。

このとき、送信元抑制メッセージを送ってくるのが、送信先から見た「宛先」だけでないことに注意したい。どこに送信したかではなく、途中の経路がトラフィックを流しきれない場合も、そのデータグラムを捨てたホストから送信先抑制メッセージが発行される。

実際、インターネットの規約には、みんなで協調しあって幸せになりましょう的なものが多い。そのため、協調性を考えない実装やアプリケーション\footnote{メールサーバのあれとか。送信側の限界までコネクションを張ろうとするので、相手殺しと言われていた。}はものすごく嫌われる。

LinuxはKernel2.2以降で、送信元抑制メッセージへのの対応を削除している。

\subsection{リダイレクト ( ICMP\_REDIRECT)}

あるルータR1に、同じネットワークにあるホストから他のネットワーク宛のデータグラムが到達したとする。もし、同一のネットワーク内に宛先となったネットワークに、ネットワーク的により近い3ネットワークアクセス層に接続しているルータR2があるとしよう。

データグラムを受信したルータR1が、ルータR2を経由した方が宛先により近いことを知っていれば、送信元ホストに、リダイレクトメッセージを送出する(may)。このリダイレクトメッセージは、R2のIPアドレスを情報として含む。

リダイレクトメッセージを送信したルータR1は、受信したデータグラムをネクストホップへ転送する。つまり、リダイレクトメッセージのきっかけとなったデータグラムは破棄せず、R1が持つ経路情報に従って、次のネットワーク人展そうされる。

リダイレクトメッセージを受け取ったホストは、「利用を勧められた」R2を利用しても良い(may)。

\subsection{エコー・エコーリプライ(ICMP\_ECHO ICMP\_ECHOREPLY)}

ICMPエコーメッセージは、宛先ホストに、データ部分をそのまま、エコーリプライメッセージのデータ部分として返すことを要求するメッセージである。 ICMPエコーメッセージを受け取ったホストは、そのデータ部分をICMPエコーリプライメッセージのデータとして、ICMPエコーメッセージを送信してきたホストに、ICMPエコーリプライメッセージを送信する。つまり、エコーメッセージとエコーリプライメッセージは、山びこ、つまりエコーとしてどうさする。

エコーとエコーリプライを利用しているアプリケーションが、ネットワークの疎通確認に用いるpingである。そのため、pingのことをICMP echoと記述する場合がある。\footnote{WindowsXP SP2のファイアウオール機能では、ICMP Echoへの応答許可の設定項目がある。これは、ping仁王等するかどうかということであると考えてよい。}

エコー、エコーリプライには、識別子とシーケンス番号のフィールドがあるが、その使用方法に関しての規定はない。要求と応答の照合を助けるために使用する、とだけ規定されている。

\subsection{タイムスタンプ・タイムスタンプリプライ(ICMP\_TIMESTAMP ICMP\_TIMESTAMPREPLY)}

タイムスタンプの付いたメッセージを送信し、相手から到着時とリプライ時の情報を追加して返してもらう。これによって、例えばICMPメッセージの往復時間を計ることができる。\footnote{RFC792ではUTCの深夜0時からの経過ミリ秒を32ビットで表したものと定義している。Linuxの実装では、1970年1月1日午前0時からの経過ミリ秒を64ビットで表す、俗にいうUnix timeを用いる}

識別子とシーケンス番号のフィールドがあるが、その使用方法に関しての規定はない。要求と応答の照合を助けるために使用する、とだけ規定されている。
\subsection{情報リクエスト・情報リクエストリプライ}

接続しているネットワークをホストが調べるのに使用するメッセージである。このメッセージを載せるデータグラムの、IPヘッダの送信元と宛先には0を記載することができる。つまり、発信元も宛先も書かなくてい。このことで判るように、このメッセージは、ネットワークアクセス層の機能だけで通信できる範囲にしか届かない。

逆に、このリクエストに応答するホストは、必ず送信元を特定できるIPデータグラムとして、情報リクエストリプライのメッセージを送信しなければならない。

識別子とシーケンス番号のフィールドがあるが、その使用方法に関しての規定はない。要求と応答の照合を助けるために使用する、とだけ規定されている。

\subsection{アドレスマスクリクエスト・アドレスマスクリプライ( ICMP\_MASKREQ ICMP\_MASKREQ\_ REPLY)}

RFC950で追加されたICMPメッセージで、ネットマスク情報を伝達するのに用いる。まず、アドレスマスクリクエストをホストがルータに送信する。ルータは、アドレスマスクリプライで、ネットマスクを通知する。ルータはアドレスマスクリクエストがあれば応答しなければならない(must)。

識別子とシーケンス番号のフィールドがあるが、その使用方法に関しての規定はない。要求と応答の照合を助けるために使用する、とだけ規定されている。

実際には、アドレスマスクリクエスト、アドレスマスクリプライが使用されることはあまりない。なぜなら、DHCPでIPアドレスを配布している環境では、アドレスマスクリクエストではなく、DHCPのの応答によってネットマスクを知らせることが多いためである。

\section{ICMPを使用するアプリケーション}

ICMPを使用するアプリケーションは、ネットワークの診断などに使用されるものが多い。その代表的なものをいくつか紹介しよう。

\subsection{ping}

ICMPを使用するアプリケーションで最も有名なものがpingである。通常はICMP\_ ECHOを使用し、ICMP\_ECHO\_REPLYが戻ってくれば、宛先ホストとの通信が「往復した」ことが確認できる。通常は、pingに応答があったこともって、宛先との疎通がとれた、として扱う。

pingコマンドでRTT(Round Trip time 往復時間)がわかるのは、メッセージとして送信時刻が記載されているためである。通常は、タイムスタンプ￥タイムスタンプリプライメッセージは使用しない。\footnote{FreeBSDのping実装では、ICMP\_MASKREQ無効(デフォルト)で、-Mオプションをつけることで、タイムスタンプメッセージでping を送出することができる。}

\subsection{traceroute}

tracerouteは、宛先ホストまでのネットワーク上の経路を調べるアプリケーションである。tracerouteによって調べられる経路とは、通過するルータとその順番である。tracerouteは、ICMPとインターネットプロトコルとを併用して、この経路の割り出しを行う。

tracerouteでは、経路を調べたい宛先にむけたIPデータグラムを送出する。このとき、IPヘッダのTTLを、TTL=1として送出する。するとおそらく、同じネットワークにあるデフォルトルートからまず、TTL=1のデータグラムが送信されるだろう。だが、このデータグラムは、宛先が同じネットワークでない限り、宛先までたどり着かず、tracerouteが動作しているホストのデフォルトルートであるルータで、TTLから1引かれてTTL=0となり、破棄されるだろう。その際に、ICMP\_TIME\_EXCEEDEDがホストに送信される。これによって、最初の経由先として、デフォルトルートのルータが判明する。

次に、TTL=2としたデータグラムを送出すると、デフォルトルートの次に通過するルータから、ICMP\_TIME\_EXCEEDEDが返される。そうしたら、こんどはTTLを3にしたIPデータグラムを送信する。この家庭を繰り返していくと、最終的に宛先とするホストから、 ICMP\_TIME\_EXCEEDEDが戻るはずである。

このとき、ICMP\_TIME\_EXCEEDEDを返してきたホストの一覧を、送信したデータグラムのTTLの順番に並べると、宛先ホストまでの経路となる。

